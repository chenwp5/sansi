# MySQL查询原理

## 一、单表访问方法

MySQL执行查询语句的方式称之为`访问方法`或者`访问类型`。

### 1.1 const

MySQL中把通过主键或者唯一二级索引列与常量的等值比较来定位一条记录的访问方法定义为：`const`，意思是常数级别的，代价是可以忽略不计的。

```
SELECT * FROM table WHERE key = 'value'; //key为主键或唯一二级索引
```

### 1.2 ref

MySQL中把通过普通二级索引列与常量的等值比较来定位记录的访问方法定义为：`ref`。因为普通二级索引叶子节点的数据不具有唯一性，所以可能找到多条对应的记录，然后再去回表。

```
SELECT * FROM table WHERE key1 = 'value'; //key1为普通二级索引
```

### 1.3 ref_or_null

有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：

```
SELECT * FROM table WHERE key1 = 'abc' OR key1 IS NULL;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为：`ref_or_null`

![img](.\img\ref_or_null.png)

### 1.4 range

当搜索条件不只是要求索引列与常数的等值匹配，而是索引列需要匹配某个或某些范围的值时，例如

```
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

此事如果采用`二级索引 + 回表`的方式来查询的话，我们就把这种利用索引进行范围匹配的访问方法称之为：`range`。

### 1.5 index

当查询列表中的字段和查询条件中的字段都包含于某个复合索引中时，MySQL只需要遍历二级索引记录即可，我们将这种执行方式称之为：`index`。

```
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
```

### 1.6 all

使用全表扫描执行查询的方式称之为：`all`。

## 二、表连接

### 2.1 连接的本质

`连接(JOIN)`的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。所以我们把t1和t2两个表连接起来的过程如下图所示：

![img](.\img\lianjie.png)

这个过程看起来就是把`t1`表的记录和`t2`的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为`笛卡尔积`。

### 2.2 内连接和外连接

- 对于`内连接`的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。
- 对于`外连接`的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

在`MySQL`中，根据选取驱动表的不同，外连接仍然可以细分为2种：

- 左外连接

  选取左侧的表为驱动表。

- 右外连接

  选取右侧的表为驱动表。

### 2.3 连接的原理

#### 2.3.1 Nested-Loop Join

首先确定第一个需要查询的表，这个表称之为`驱动表`。根据驱动表的查询条件得到一个结果集，然后遍历该结果集依次与另一个表去匹配，我们将另一个表称为`被驱动表`。我们把对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`（英文名：`fanout`）。因此可以得知**驱动表只会被访问一遍，但被驱动表却要被访问多次，访问次数取决于对驱动表扇出值。**过程如下所示：

![img](.\img\lianjieguocheng.png)

如果有3个表进行连接的话，那么`步骤2`中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，重复上边过程。

我们将这种连接执行方式称之为`嵌套循环连接`（`Nested-Loop Join`），这是最简单，也是最笨拙的一种连接查询算法。

#### 2.3.2 使用索引加快连接速度

嵌套循环链接中是需要多次访问被驱动表，如果每次都是全表扫描的话，那么效率就非常低。因此可以考虑添加索引来提升查询速度。

```
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

该语句查询过程如下：

![img](.\img\lianjie1.png)

假设驱动表`t1`后的结果集中有两条记录，`嵌套循环连接`算法需要对被驱动表查询2次：

- 当`t1.m1 = 2`时，去查询一遍`t2`表，对`t2`表的查询语句相当于：

```
SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 < 'd';
```

- 当`t1.m1 = 3`时，再去查询一遍`t2`表，此时对`t2`表的查询语句相当于：

```
SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 < 'd';
```

可以看到，原来的`t1.m1 = t2.m2`这个涉及两个表的过滤条件在针对`t2`表做查询时关于`t1`表的条件就已经确定了，所以我们只需要单单优化对`t2`表的查询了，上述两个对`t2`表的查询语句中利用到的列是`m2`和`n2`列，我们可以：

- m2列添加索引，因为对m2是等值查询，所以其访问方式为ref，回表之后再判断`t2.n2 < d`这个条件是否成立

假如m2是主键或者唯一二级索引，那么其访问是常数级别的。在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为`const`。在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：`eq_ref`。

- 在`n2`列上建立索引，涉及到的条件是`t2.n2 < 'd'`，可能用到`range`的访问方法，假设使用`range`的访问方法对`t2`表的查询的话，需要回表之后再判断在`m2`列上的条件是否成立。
- 建立复合索引(m2,n2)，这种方式应该是最好的方案，可以减少回表的次数。

#### 2.3.3 Block Nested-Loop Join

`MySQL`提出了一个`join buffer`的概念，`join buffer`就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个`join buffer`中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和`join buffer`中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的`I/O`代价。

最好的情况是`join buffer`足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了。设计`MySQL`的大叔把这种加入了`join buffer`的嵌套循环连接算法称之为`基于块的嵌套连接`（Block Nested-Loop Join）算法。

> 注：从 MySQL 8.0.20 开始，删除了对块嵌套循环的支持，并且服务器在以前使用块嵌套循环的任何地方都采用哈希连接。

#### 2.3.4 Hash Join

> 